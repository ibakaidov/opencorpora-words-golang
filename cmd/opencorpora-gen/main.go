package main

import (
    "bufio"
    "bytes"
    "context"
    "flag"
    "fmt"
    "go/format"
    "log"
    "os"
    "path/filepath"
    "sort"
    "strconv"
    "strings"

    "github.com/ibakaidov/opencorpora-words-golang/opencorpora"
)

func main() {
    var (
        outPath  string
        dictURL  string
        cacheDir string
        zipPath  string
        textPath string
    )

    flag.StringVar(&outPath, "out", filepath.Join("opencorpora", "enums_gen.go"), "output file path")
    flag.StringVar(&dictURL, "dict-url", opencorpora.DefaultDictionaryURL, "dictionary zip URL")
    flag.StringVar(&cacheDir, "cache", "", "cache directory (default: OS user cache)/opencorpora")
    flag.StringVar(&zipPath, "zip", "", "existing zip archive path (optional)")
    flag.StringVar(&textPath, "text", "", "existing extracted dictionary path (optional)")
    flag.Parse()

    ctx := context.Background()

    opts := []opencorpora.Option{
        opencorpora.WithDictionaryURL(dictURL),
    }
    if cacheDir != "" {
        opts = append(opts, opencorpora.WithCacheDir(cacheDir))
    }
    if zipPath != "" {
        opts = append(opts, opencorpora.WithZipPath(zipPath))
    }
    if textPath != "" {
        opts = append(opts, opencorpora.WithTextPath(textPath))
    }

    dictPath, err := opencorpora.EnsureDictionary(ctx, opts...)
    if err != nil {
        log.Fatalf("ensure dictionary: %v", err)
    }

    pos, grams, err := collectTags(ctx, dictPath)
    if err != nil {
        log.Fatalf("collect tags: %v", err)
    }

    if err := writeEnums(outPath, pos, grams); err != nil {
        log.Fatalf("write enums: %v", err)
    }
}

func collectTags(ctx context.Context, path string) ([]string, []string, error) {
    f, err := os.Open(path)
    if err != nil {
        return nil, nil, fmt.Errorf("open %s: %w", path, err)
    }
    defer f.Close()

    scanner := bufio.NewScanner(f)
    scanner.Buffer(make([]byte, 0, 64*1024), 4*1024*1024)

    pos := make(map[string]struct{})
    grams := make(map[string]struct{})

    for scanner.Scan() {
        if err := ctx.Err(); err != nil {
            return nil, nil, err
        }
        line := strings.TrimSpace(scanner.Text())
        if line == "" {
            continue
        }
        if isNumber(line) {
            continue
        }
        parts := strings.SplitN(line, "\t", 2)
        if len(parts) != 2 {
            continue
        }
        tokens := splitTokens(parts[1])
        if len(tokens) == 0 {
            continue
        }
        pos[tokens[0]] = struct{}{}
        for _, t := range tokens[1:] {
            grams[t] = struct{}{}
        }
    }

    if err := scanner.Err(); err != nil {
        return nil, nil, fmt.Errorf("scan dictionary: %w", err)
    }

    posList := make([]string, 0, len(pos))
    for p := range pos {
        posList = append(posList, p)
    }
    sort.Strings(posList)

    gramList := make([]string, 0, len(grams))
    for g := range grams {
        gramList = append(gramList, g)
    }
    sort.Strings(gramList)

    return posList, gramList, nil
}

func writeEnums(path string, pos []string, grams []string) error {
    var buf bytes.Buffer
    buf.WriteString("//go:build !generate\n")
    buf.WriteString("// +build !generate\n\n")
    buf.WriteString("// Code generated by opencorpora-gen; DO NOT EDIT.\n")
    buf.WriteString("package opencorpora\n\n")
    buf.WriteString("import \"strconv\"\n\n")

    namedPOS := makeNamed(pos)
    namedGrams := makeNamed(grams)

    buf.WriteString("const (\n")
    buf.WriteString("    PartUnknown PartOfSpeech = iota\n")
    for _, p := range namedPOS {
        buf.WriteString(fmt.Sprintf("    Part%s\n", p.Name))
    }
    buf.WriteString(")\n\n")

    buf.WriteString("const (\n")
    buf.WriteString("    GrammemeUnknown Grammeme = iota\n")
    for _, g := range namedGrams {
        buf.WriteString(fmt.Sprintf("    Grammeme%s\n", g.Name))
    }
    buf.WriteString(")\n\n")

    buf.WriteString("var partToString = map[PartOfSpeech]string{\n")
    buf.WriteString("    PartUnknown: \"unknown\",\n")
    for _, p := range namedPOS {
        buf.WriteString(fmt.Sprintf("    Part%s: \"%s\",\n", p.Name, p.Token))
    }
    buf.WriteString("}\n\n")

    buf.WriteString("var partFromString = map[string]PartOfSpeech{\n")
    for _, p := range namedPOS {
        buf.WriteString(fmt.Sprintf("    \"%s\": Part%s,\n", p.Token, p.Name))
    }
    buf.WriteString("}\n\n")

    buf.WriteString("var grammemeToString = map[Grammeme]string{\n")
    buf.WriteString("    GrammemeUnknown: \"unknown\",\n")
    for _, g := range namedGrams {
        buf.WriteString(fmt.Sprintf("    Grammeme%s: \"%s\",\n", g.Name, g.Token))
    }
    buf.WriteString("}\n\n")

    buf.WriteString("var grammemeFromString = map[string]Grammeme{\n")
    for _, g := range namedGrams {
        buf.WriteString(fmt.Sprintf("    \"%s\": Grammeme%s,\n", g.Token, g.Name))
    }
    buf.WriteString("}\n\n")

    buf.WriteString("var allPartsOfSpeech = []PartOfSpeech{\n")
    for _, p := range namedPOS {
        buf.WriteString(fmt.Sprintf("    Part%s,\n", p.Name))
    }
    buf.WriteString("}\n\n")

    buf.WriteString("var allGrammemes = []Grammeme{\n")
    for _, g := range namedGrams {
        buf.WriteString(fmt.Sprintf("    Grammeme%s,\n", g.Name))
    }
    buf.WriteString("}\n\n")

    buf.WriteString(partHelpers())
    buf.WriteString(gramHelpers())

    formatted, err := format.Source(buf.Bytes())
    if err != nil {
        return fmt.Errorf("format: %w", err)
    }

    if err := os.WriteFile(path, formatted, 0o644); err != nil {
        return fmt.Errorf("write %s: %w", path, err)
    }
    return nil
}

func partHelpers() string {
    return `func (p PartOfSpeech) String() string {
    if s, ok := partToString[p]; ok {
        return s
    }
    return "PartOfSpeech(" + strconv.Itoa(int(p)) + ")"
}

func ParsePartOfSpeech(s string) (PartOfSpeech, bool) {
    p, ok := partFromString[s]
    return p, ok
}

func AllPartsOfSpeech() []PartOfSpeech {
    out := make([]PartOfSpeech, len(allPartsOfSpeech))
    copy(out, allPartsOfSpeech)
    return out
}
`
}

func gramHelpers() string {
    return `func (g Grammeme) String() string {
    if s, ok := grammemeToString[g]; ok {
        return s
    }
    return "Grammeme(" + strconv.Itoa(int(g)) + ")"
}

func ParseGrammeme(s string) (Grammeme, bool) {
    g, ok := grammemeFromString[s]
    return g, ok
}

func AllGrammemes() []Grammeme {
    out := make([]Grammeme, len(allGrammemes))
    copy(out, allGrammemes)
    return out
}
`
}

func goName(token string) string {
    token = strings.TrimSpace(token)
    if token == "" {
        return ""
    }
    parts := splitIdentParts(token)
    for i, p := range parts {
        if p == "" {
            continue
        }
        parts[i] = strings.ToUpper(p[:1]) + strings.ToLower(p[1:])
    }
    return strings.Join(parts, "")
}

func splitIdentParts(token string) []string {
    split := func(r rune) bool {
        return !((r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9'))
    }
    parts := strings.FieldsFunc(token, split)
    if len(parts) == 0 {
        return []string{"X"}
    }
    return parts
}

func isNumber(s string) bool {
    _, err := strconv.Atoi(s)
    return err == nil
}

func splitTokens(s string) []string {
    s = strings.ReplaceAll(s, ",", " ")
    return strings.Fields(s)
}

type namedToken struct {
    Name  string
    Token string
}

func makeNamed(tokens []string) []namedToken {
    used := make(map[string]int)
    out := make([]namedToken, 0, len(tokens))
    for _, t := range tokens {
        base := goName(t)
        count := used[base]
        used[base] = count + 1

        name := base
        if count > 0 {
            name = fmt.Sprintf("%s%d", base, count+1)
        }
        out = append(out, namedToken{Name: name, Token: t})
    }
    return out
}
